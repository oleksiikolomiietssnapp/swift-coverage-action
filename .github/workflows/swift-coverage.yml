name: Swift Test Coverage

on:
  workflow_call:
    inputs:
      xcode-version:
        description: 'Xcode version to use (default: system default)'
        required: false
        type: string
        default: ''
      source-path-override:
        description: 'Override source path pattern (default: {PROJECT}/Sources)'
        required: false
        type: string
      project-name-override:
        description: 'Override project name (default: repository name)'
        required: false
        type: string
      coverage-comment-header:
        description: 'Header for coverage comment'
        required: false
        type: string
        default: '### üõ°Ô∏è Code Coverage Report'
      working-directory:
        description: 'Working directory for Swift commands (default: repository root)'
        required: false
        type: string
        default: '.'
      skip-label:
        description: 'Label name to skip workflow execution (default: skip-coverage)'
        required: false
        type: string
        default: 'skip-coverage'
    outputs:
      coverage-percentage:
        description: 'The calculated coverage percentage'
        value: ${{ jobs.coverage.outputs.coverage }}

env:
  XCODE_PATH: '/Applications/Xcode_${{ inputs.xcode-version }}.app/Contents/Developer'
  COVERAGE_SUMMARY_FILE: '${{ github.workspace }}/coverage_summary.txt'

jobs:
  coverage:
    if: ${{ !contains(github.event.pull_request.labels.*.name, inputs.skip-label) }}
    runs-on: macos-26
    permissions:
      contents: read
      pull-requests: write
      issues: write
    outputs:
      coverage: ${{ steps.extract.outputs.coverage }}
    defaults:
      run:
        working-directory: ${{ inputs.working-directory }}

    steps:
    - uses: actions/checkout@v4

    - name: List Xcode installations
      run: sudo ls -1 /Applications | grep "Xcode"

    - name: Select Xcode ${{ inputs.xcode-version }}
      if: inputs.xcode-version != ''
      run: sudo xcode-select -s ${{ env.XCODE_PATH }}

    - name: Verify Swift Version
      run: swift --version

    - name: Run Swift Tests with Coverage
      run: |
        swift test --enable-swift-testing --enable-code-coverage
        CODECOV_PATH=$(swift test --enable-swift-testing --enable-code-coverage --show-codecov-path)
        echo "CODECOV_PATH=$CODECOV_PATH" >> $GITHUB_ENV

    - name: Extract Coverage Data
      id: extract
      run: |
        # Set project name and source path
        PROJECT_NAME="${{ inputs.project-name-override }}"
        if [ -z "$PROJECT_NAME" ]; then
          PROJECT_NAME="${{ github.event.repository.name }}"
        fi

        SOURCE_PATH="${{ inputs.source-path-override }}"
        if [ -z "$SOURCE_PATH" ]; then
          SOURCE_PATH="${PROJECT_NAME}/Sources"
        fi


        # Check if there are any actual source files to report on
        SOURCE_FILE_COUNT=$(jq -r '.data[0].files[] | select(.filename | test("/\\.build/") | not) | select(.filename | test("\\.swift$")) | select(.filename | test("/(Tests?|test)/") | not) | .filename' "$CODECOV_PATH" | wc -l)

        if [ "$SOURCE_FILE_COUNT" -eq 0 ]; then
          # Create a placeholder entry when no source files exist
          ALL_FILES="$PROJECT_NAME|0|0"
        else
          # Extract all Swift files excluding build artifacts
          ALL_FILES=$(jq -r '.data[0].files[] | select(.filename | test("/\\.build/") | not) | select(.filename | test("\\.swift$")) | select(.filename | test("/(Tests?|test)/") | not) | "\(.filename)|\(.summary.lines.count)|\(.summary.lines.covered)"' "$CODECOV_PATH")
        fi

        # Initialize table
        cat <<EOF > ${{ env.COVERAGE_SUMMARY_FILE }}
        |   ‚Ññ  | Name | Executable Lines | Coverage |
        |:----:|------|-----------------:|---------:|
        EOF

        # Create temporary files for target data
        TARGETS_DATA=$(mktemp)

        # Parse files and group by target
        while IFS='|' read -r filename total_lines covered_lines; do
          if [ -n "$filename" ]; then
            # Extract target name from file path patterns:
            # Pattern 1: /path/to/TargetName/Sources/...
            # Pattern 2: /path/to/Sources/TargetName/...
            # Pattern 3: /path/to/TargetName/...
            target_name=""

            if echo "$filename" | grep -q '/Sources/[^/]*/'; then
              # Pattern: .../Sources/TargetName/...
              target_name=$(echo "$filename" | sed -E 's|.*/Sources/([^/]+)/.*|\1|')
            elif echo "$filename" | grep -q '/Sources/[^/]*\.swift$'; then
              # Pattern: .../Sources/file.swift (direct in Sources)
              target_name=$(echo "$filename" | sed -E 's|.*/Sources/([^/]*)\.swift$|\1|')
            else
              target_name="$PROJECT_NAME"
            fi


            # Skip if target name looks like a test
            if echo "$target_name" | grep -qi test; then
              continue
            fi

            # Write target data to temp file
            echo "$target_name|$total_lines|$covered_lines" >> "$TARGETS_DATA"
          fi
        done <<< "$ALL_FILES"

        # Aggregate data by target
        AGGREGATED_DATA=$(mktemp)
        if [ -s "$TARGETS_DATA" ]; then
          sort "$TARGETS_DATA" | awk -F'|' '
          {
            target = $1
            total_lines[target] += $2
            covered_lines[target] += $3
          }
          END {
            for (target in total_lines) {
              print target "|" total_lines[target] "|" covered_lines[target]
            }
          }' > "$AGGREGATED_DATA"
        fi

        # Generate table rows for each target
        target_counter=1
        total_coverage_sum=0
        target_count=0

        if [ -s "$AGGREGATED_DATA" ]; then
          # Process each target and add to table
          while IFS='|' read -r target_name total_lines covered_lines; do
            if [ -n "$target_name" ]; then
              if [ $total_lines -gt 0 ]; then
                target_coverage=$(echo "scale=6; $covered_lines * 100 / $total_lines" | bc)
              else
                target_coverage=0
              fi

              target_coverage_rounded=$(echo "$target_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')
              target_coverage_with_percentage="${target_coverage_rounded}%"

              # Add target row to table
              echo "| $target_counter | $target_name | $total_lines | **$target_coverage_with_percentage** |" >> ${{ env.COVERAGE_SUMMARY_FILE }}

              # For overall average calculation
              echo "$target_coverage" >> /tmp/coverage_values.txt
              target_counter=$((target_counter + 1))

            fi
          done < <(sort "$AGGREGATED_DATA")
        else
          # Fallback: add a single entry with project name
          echo "| 1 | $PROJECT_NAME | 0 | **0%** |" >> ${{ env.COVERAGE_SUMMARY_FILE }}
        fi

        # Calculate overall average coverage
        if [ -f /tmp/coverage_values.txt ]; then
          target_count=$(wc -l < /tmp/coverage_values.txt)
          if [ $target_count -gt 0 ]; then
            total_coverage_sum=$(awk '{sum+=$1} END {print sum}' /tmp/coverage_values.txt)
            average_coverage=$(echo "scale=6; $total_coverage_sum / $target_count" | bc)
          else
            average_coverage=0
          fi
          rm -f /tmp/coverage_values.txt
        else
          average_coverage=0
        fi

        # Clean up temp files
        rm -f "$TARGETS_DATA" "$AGGREGATED_DATA"

        average_coverage_rounded=$(echo "$average_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')

        # Output for next steps
        echo "coverage=$average_coverage_rounded" >> $GITHUB_OUTPUT

    - name: Enable Apple Intelligence
      run: |
        echo "üì± Checking Apple Intelligence status..."
        defaults read com.apple.CloudSubscriptionFeatures.optIn "545129924" 2>/dev/null || echo "Apple Intelligence not currently enabled"

        echo "üìù Enabling Apple Intelligence..."
        defaults write com.apple.CloudSubscriptionFeatures.optIn "545129924" -bool "true"

        echo "‚úÖ Verifying setting..."
        defaults read com.apple.CloudSubscriptionFeatures.optIn "545129924"

        echo "‚è≥ Waiting for model assets to download (60s)..."
        for i in {1..12}; do
          echo "‚è±Ô∏è  ${i}0s elapsed..."
          sleep 10
        done

        echo "üîç Checking for model files..."
        find ~/Library -name "*FoundationModels*" -o -name "*LanguageModel*" 2>/dev/null | head -5 || echo "No model files found"

    - name: AI Coverage Analysis
      id: ai_analysis
      run: |
        echo "ü§ñ Starting AI Coverage Analysis..."
        echo "Coverage value: ${{ steps.extract.outputs.coverage }}%"

        cat > /tmp/analyze-coverage.swift << 'SWIFT_EOF'
        import Foundation

        #if canImport(FoundationModels)
        import FoundationModels

        print("‚úÖ FoundationModels framework is available", to: &standardError)

        guard CommandLine.arguments.count > 1,
              let coverage = Double(CommandLine.arguments[1]) else {
            print("‚ùå No coverage value provided", to: &standardError)
            print("No AI analysis available")
            exit(0)
        }

        print("üìä Coverage value received: \(coverage)%", to: &standardError)

        let prompt = """
        The code test coverage is \(String(format: "%.2f", coverage))%.
        Provide a brief assessment (1-2 sentences) of this coverage percentage.
        Focus on whether it's good, acceptable, or needs improvement.
        """

        print("üìù Checking model availability...", to: &standardError)
        let availability = SystemLanguageModel.default.availability
        print("Model availability status: \(availability)", to: &standardError)

        do {
            print("üöÄ Creating LanguageModelSession...", to: &standardError)
            let session = LanguageModelSession()
            print("üí¨ Sending prompt to model...", to: &standardError)
            let response = try await session.respond(to: prompt)
            print("‚úÖ Response received successfully", to: &standardError)
            print(response.content)
        } catch {
            print("‚ùå Error during AI analysis: \(error)", to: &standardError)
            print("AI analysis unavailable: \(error.localizedDescription)")
        }
        #else
        print("‚ùå FoundationModels framework is NOT available", to: &standardError)
        print("AI analysis requires macOS 26+")
        #endif

        var standardError = FileHandle.standardError

        extension FileHandle: TextOutputStream {
            public func write(_ string: String) {
                guard let data = string.data(using: .utf8) else { return }
                self.write(data)
            }
        }
        SWIFT_EOF

        echo "üîß Compiling and running Swift script..."
        AI_ASSESSMENT=$(swift /tmp/analyze-coverage.swift "${{ steps.extract.outputs.coverage }}" 2>&1)
        echo "üì§ AI Assessment output:"
        echo "$AI_ASSESSMENT"

        # Extract only the actual assessment (last line that's not debug info)
        CLEAN_ASSESSMENT=$(echo "$AI_ASSESSMENT" | grep -v "^‚úÖ\|^‚ùå\|^üìä\|^üìù\|^üöÄ\|^üí¨\|^Model availability" | tail -1)

        if [ -n "$CLEAN_ASSESSMENT" ] && [ "$CLEAN_ASSESSMENT" != "AI analysis requires macOS 26+" ] && [ "$CLEAN_ASSESSMENT" != "No AI analysis available" ]; then
          echo "üíæ Saving AI assessment to output..."
          echo "ai_assessment<<EOF" >> $GITHUB_OUTPUT
          echo "$CLEAN_ASSESSMENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          echo "‚ö†Ô∏è No valid AI assessment generated"
        fi
        rm -f /tmp/analyze-coverage.swift

    - name: Comment on Pull Request
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const coverageOutput = fs.readFileSync('${{ env.COVERAGE_SUMMARY_FILE }}', 'utf8');
          const aiAssessment = `${{ steps.ai_analysis.outputs.ai_assessment }}`;

          let aiSection = '';
          if (aiAssessment && aiAssessment.trim()) {
            aiSection = `\n### ü§ñ AI Assessment\n${aiAssessment}\n`;
          }

          const newComment = `
          ${{ inputs.coverage-comment-header }}

          ${coverageOutput}
          ${aiSection}
          _Generated by [Swift Coverage Action](https://github.com/oleksiikolomiietssnapp/swift-coverage-action)._
          `;

          // Fetch existing comments
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.payload.pull_request.number,
          });

          // Identify and delete previous bot comments
          const botComments = comments.data.filter(comment =>
            comment.body.includes("${{ inputs.coverage-comment-header }}")
          );

          for (const botComment of botComments) {
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
            });
          }

          // Create a comment on the pull request
          await github.rest.issues.createComment({
            issue_number: context.payload.pull_request.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: newComment,
          });
