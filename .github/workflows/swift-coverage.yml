name: Swift Test Coverage

on:
  workflow_call:
    inputs:
      xcode-version:
        description: 'Xcode version to use'
        required: false
        type: string
        default: '16.2'
      source-path-override:
        description: 'Override source path pattern (default: {PROJECT}/Sources)'
        required: false
        type: string
      project-name-override:
        description: 'Override project name (default: repository name)'
        required: false
        type: string
      coverage-comment-header:
        description: 'Header for coverage comment'
        required: false
        type: string
        default: '### ðŸ›¡ï¸ Code Coverage Report'
    outputs:
      coverage-percentage:
        description: 'The calculated coverage percentage'
        value: ${{ jobs.coverage.outputs.coverage }}

env:
  XCODE_PATH: '/Applications/Xcode_${{ inputs.xcode-version }}.app/Contents/Developer'
  COVERAGE_SUMMARY_FILE: 'coverage_summary.txt'

jobs:
  coverage:
    runs-on: macos-latest
    outputs:
      coverage: ${{ steps.extract.outputs.coverage }}

    steps:
    - uses: actions/checkout@v4

    - name: List Xcode installations
      run: sudo ls -1 /Applications | grep "Xcode"

    - name: Select Xcode ${{ inputs.xcode-version }}
      run: sudo xcode-select -s ${{ env.XCODE_PATH }}

    - name: Run Swift Tests with Coverage
      run: |
        swift test --enable-swift-testing --enable-code-coverage
        CODECOV_PATH=$(swift test --enable-swift-testing --enable-code-coverage --show-codecov-path)
        echo "CODECOV_PATH=$CODECOV_PATH" >> $GITHUB_ENV

    - name: Extract Coverage Data
      id: extract
      run: |
        # Set project name and source path
        PROJECT_NAME="${{ inputs.project-name-override }}"
        if [ -z "$PROJECT_NAME" ]; then
          PROJECT_NAME="${{ github.event.repository.name }}"
        fi

        SOURCE_PATH="${{ inputs.source-path-override }}"
        if [ -z "$SOURCE_PATH" ]; then
          SOURCE_PATH="${PROJECT_NAME}/Sources"
        fi

        echo "Using PROJECT_NAME: $PROJECT_NAME"
        echo "Using SOURCE_PATH: $SOURCE_PATH"

        # Extract all source files from coverage data, excluding test files and build artifacts
        ALL_FILES=$(jq -r '.data[0].files[] | select(.filename | test("/(Tests?|test)/") | not) | select(.filename | test("/\\.build/") | not) | select(.filename | test("/Sources/|/src/") or (test("/\\.(swift|m|mm)$") and test("/Tests?/") | not)) | "\(.filename)|\(.summary.lines.count)|\(.summary.lines.covered)"' "$CODECOV_PATH")

        # Initialize table
        cat <<EOF > ${{ env.COVERAGE_SUMMARY_FILE }}
        |   â„–  | Name | Executable Lines | Coverage |
        |:----:|------|-----------------:|---------:|
        EOF

        # Group files by target name and calculate coverage
        declare -A target_totals
        declare -A target_covered
        declare -A target_names

        # Parse files and group by target
        while IFS='|' read -r filename total_lines covered_lines; do
          if [ -n "$filename" ]; then
            # Extract target name from file path patterns:
            # Pattern 1: /path/to/TargetName/Sources/...
            # Pattern 2: /path/to/Sources/TargetName/...
            # Pattern 3: /path/to/TargetName/...
            target_name=""

            if [[ "$filename" =~ /([^/]+)/Sources/ ]]; then
              target_name="${BASH_REMATCH[1]}"
            elif [[ "$filename" =~ /Sources/([^/]+)/ ]]; then
              target_name="${BASH_REMATCH[1]}"
            elif [[ "$filename" =~ /([^/]+)/[^/]+\.swift$ ]]; then
              target_name="${BASH_REMATCH[1]}"
            else
              target_name="$PROJECT_NAME"
            fi

            # Skip if target name looks like a test
            if [[ "$target_name" =~ [Tt]est ]]; then
              continue
            fi

            # Accumulate totals for this target
            target_totals["$target_name"]=$((${target_totals["$target_name"]:-0} + total_lines))
            target_covered["$target_name"]=$((${target_covered["$target_name"]:-0} + covered_lines))
            target_names["$target_name"]=1
          fi
        done <<< "$ALL_FILES"

        # Generate table rows for each target
        target_counter=1
        total_coverage_sum=0
        target_count=0

        for target_name in $(printf '%s\n' "${!target_names[@]}" | sort); do
          total_lines=${target_totals["$target_name"]}
          covered_lines=${target_covered["$target_name"]}

          if [ $total_lines -gt 0 ]; then
            target_coverage=$(echo "scale=6; $covered_lines * 100 / $total_lines" | bc)
          else
            target_coverage=0
          fi

          target_coverage_rounded=$(echo "$target_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')
          target_coverage_with_percentage="${target_coverage_rounded}%"

          # Add target row to table
          echo "| $target_counter | $target_name | $total_lines | **$target_coverage_with_percentage** |" >> ${{ env.COVERAGE_SUMMARY_FILE }}

          total_coverage_sum=$(echo "$total_coverage_sum + $target_coverage" | bc)
          target_counter=$((target_counter + 1))
          target_count=$((target_count + 1))
        done

        # Calculate overall average coverage
        if [ $target_count -gt 0 ]; then
          average_coverage=$(echo "scale=6; $total_coverage_sum / $target_count" | bc)
        else
          average_coverage=0
        fi

        average_coverage_rounded=$(echo "$average_coverage" | awk '{print int($1 * 100 + 0.5) / 100}')

        # Output for next steps
        echo "coverage=$average_coverage_rounded" >> $GITHUB_OUTPUT

    - name: Comment on Pull Request
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const coverageOutput = fs.readFileSync('${{ env.COVERAGE_SUMMARY_FILE }}', 'utf8');

          const newComment = `
          ${{ inputs.coverage-comment-header }}

          ${coverageOutput}

          _Generated by [Swift Coverage Action](https://github.com/oleksiikolomiietssnapp/swift-coverage-action)._
          `;

          // Fetch existing comments
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.payload.pull_request.number,
          });

          // Identify and delete previous bot comments
          const botComments = comments.data.filter(comment =>
            comment.body.includes("${{ inputs.coverage-comment-header }}")
          );

          for (const botComment of botComments) {
            await github.rest.issues.deleteComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
            });
          }

          // Create a comment on the pull request
          await github.rest.issues.createComment({
            issue_number: context.payload.pull_request.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: newComment,
          });
